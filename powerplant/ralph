#!/usr/bin/env bash
# Ralph Wiggum - Autonomous AI Development Loop
# https://ghuntley.com/ralph/
#
# Usage: ralph [plan|build] [options]
#   ralph              - Build mode, unlimited iterations
#   ralph 10           - Build mode, max 10 iterations  
#   ralph plan         - Plan mode, generate implementation plan
#   ralph init         - Initialize ralph in current repo
#   ralph status       - Show current status
#   ralph log          - Tail the current log
#
# Options:
#   --max-cost N       - Stop when cumulative cost exceeds $N (default: unlimited)
#   --max-failures N   - Circuit breaker: stop after N consecutive failures (default: 3)
#   --completion-promise "TEXT" - Stop when output contains TEXT

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Default limits
DEFAULT_MAX_FAILURES=3

# Find repo root
find_repo_root() {
  local dir="$PWD"
  while [[ "$dir" != "/" ]]; do
    if [[ -d "$dir/.git" ]]; then
      echo "$dir"
      return 0
    fi
    dir="$(dirname "$dir")"
  done
  echo ""
  return 1
}

REPO_ROOT=$(find_repo_root) || {
  echo -e "${RED}Error: Not in a git repository${NC}"
  exit 1
}

RALPH_DIR="$REPO_ROOT/ralph"
LOG_DIR="$REPO_ROOT/build/ralph-logs"
PROMPT_PLAN="$RALPH_DIR/PROMPT_plan.md"
PROMPT_BUILD="$RALPH_DIR/PROMPT_build.md"
IMPL_PLAN="$RALPH_DIR/IMPLEMENTATION_PLAN.md"
SPECS_DIR="$RALPH_DIR/specs"
METRICS_FILE="$LOG_DIR/metrics.json"

# Ensure log directory exists
mkdir -p "$LOG_DIR"

# ============================================================================
# Metrics & Cost Tracking
# ============================================================================

init_metrics() {
  cat > "$METRICS_FILE" << 'EOF'
{"total_cost": 0, "total_iterations": 0, "total_tokens_in": 0, "total_tokens_out": 0, "failures": 0, "successes": 0, "started_at": null}
EOF
  # Set started_at
  local now=$(date -Iseconds)
  update_metric "started_at" "\"$now\""
}

get_metric() {
  local key="$1"
  if [[ -f "$METRICS_FILE" ]]; then
    python3 -c "import json; print(json.load(open('$METRICS_FILE')).get('$key', 0))" 2>/dev/null || echo "0"
  else
    echo "0"
  fi
}

update_metric() {
  local key="$1"
  local value="$2"
  if [[ -f "$METRICS_FILE" ]]; then
    python3 -c "
import json
with open('$METRICS_FILE', 'r') as f:
    data = json.load(f)
data['$key'] = $value
with open('$METRICS_FILE', 'w') as f:
    json.dump(data, f)
" 2>/dev/null || true
  fi
}

increment_metric() {
  local key="$1"
  local amount="${2:-1}"
  local current=$(get_metric "$key")
  local new=$(python3 -c "print($current + $amount)" 2>/dev/null || echo "$current")
  update_metric "$key" "$new"
}

# Extract cost from JSON log (finds last step_finish event)
extract_iteration_cost() {
  local json_log="$1"
  if [[ -f "$json_log" ]]; then
    # Get the last step_finish event's cost
    python3 -c "
import json
import sys
cost = 0
tokens_in = 0
tokens_out = 0
for line in open('$json_log'):
    try:
        event = json.loads(line.strip())
        if event.get('type') == 'step_finish':
            part = event.get('part', {})
            cost = part.get('cost', 0)
            tokens = part.get('tokens', {})
            tokens_in = tokens.get('input', 0)
            tokens_out = tokens.get('output', 0)
    except: pass
print(f'{cost},{tokens_in},{tokens_out}')
" 2>/dev/null || echo "0,0,0"
  else
    echo "0,0,0"
  fi
}

show_metrics_summary() {
  if [[ ! -f "$METRICS_FILE" ]]; then
    echo "No metrics available"
    return
  fi
  
  local total_cost=$(get_metric "total_cost")
  local iterations=$(get_metric "total_iterations")
  local tokens_in=$(get_metric "total_tokens_in")
  local tokens_out=$(get_metric "total_tokens_out")
  local failures=$(get_metric "failures")
  local successes=$(get_metric "successes")
  
  echo -e "${CYAN}Session Metrics:${NC}"
  echo -e "  Cost:       \$$(printf '%.4f' "$total_cost")"
  echo -e "  Iterations: $iterations ($successes ok, $failures failed)"
  echo -e "  Tokens:     ${tokens_in} in / ${tokens_out} out"
}

# ============================================================================
# Circuit Breaker
# ============================================================================

CONSECUTIVE_FAILURES=0

check_circuit_breaker() {
  local max_failures="$1"
  if [[ $CONSECUTIVE_FAILURES -ge $max_failures ]]; then
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${RED}CIRCUIT BREAKER TRIPPED${NC}"
    echo -e "${RED}$CONSECUTIVE_FAILURES consecutive failures detected${NC}"
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    return 1
  fi
  return 0
}

record_success() {
  CONSECUTIVE_FAILURES=0
  increment_metric "successes" 1
}

record_failure() {
  CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))
  increment_metric "failures" 1
}

# ============================================================================
# Completion Promise Detection
# ============================================================================

check_completion_promise() {
  local log_file="$1"
  local promise="$2"
  
  if [[ -z "$promise" ]]; then
    return 1  # No promise set
  fi
  
  if [[ -f "$log_file" ]] && grep -qF "$promise" "$log_file"; then
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}COMPLETION PROMISE DETECTED${NC}"
    echo -e "${GREEN}Found: $promise${NC}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    return 0
  fi
  return 1
}

# ============================================================================
# Commands
# ============================================================================

cmd_init() {
  if [[ -d "$RALPH_DIR" ]]; then
    echo -e "${YELLOW}Ralph already initialized in this repo${NC}"
    echo "  $RALPH_DIR"
    return 0
  fi

  echo -e "${BLUE}Initializing Ralph in $REPO_ROOT${NC}"
  
  mkdir -p "$RALPH_DIR" "$SPECS_DIR"

  # Create default plan prompt
  cat > "$PROMPT_PLAN" << 'EOF'
0a. Run `git branch --show-current` to identify the current branch.
0b. Study `ralph/specs/*` to learn the project specifications.
0c. Study the source code to understand the current implementation.

## Task: Gap Analysis

Compare specs against the CURRENT codebase and generate a fresh task list:

1. Use subagents to study specs and source code thoroughly
2. For each spec requirement, check if it's already implemented
3. Create tasks ONLY for what's missing or broken
4. DO NOT implement anything - planning only

## Updating an Existing Plan

The plan is disposable - regenerate it based on current reality, not the old plan.

If @ralph/IMPLEMENTATION_PLAN.md exists:
- IGNORE the old pending tasks (they may be stale)
- KEEP the "## Completed" section as historical record
- KEEP the "## Discovered Issues" section
- Generate NEW pending tasks from fresh gap analysis

## Output

Write @ralph/IMPLEMENTATION_PLAN.md with:

```markdown
# Implementation Plan

**Branch:** `<current branch>`
**Last updated:** <timestamp>

## Pending Tasks

- [ ] Task 1 (highest priority)
- [ ] Task 2
...

## Completed

- [x] Previous completed tasks (preserve from old plan)

## Discovered Issues

- Issues found during implementation (preserve from old plan)
```

Rules:
- Each task should be completable in ONE iteration
- Order by priority (most important first)
- Be specific - "Add X to Y" not "Improve Z"
EOF

  # Create default build prompt
  cat > "$PROMPT_BUILD" << 'EOF'
0a. Run `git branch --show-current` to identify the current branch.
0b. Study `ralph/specs/*` to understand requirements.
0c. Study @ralph/IMPLEMENTATION_PLAN.md for current task list.

## Branch Awareness

IMPORTANT: Check the **Branch:** field in @ralph/IMPLEMENTATION_PLAN.md.
- If it matches current branch, continue with tasks.
- If it doesn't match, the plan is from different work - proceed carefully or run `ralph plan` first.
- Update **Last updated:** when you complete a task.

## CRITICAL: ONE TASK, THEN EXIT

1. Pick ONE incomplete item from @ralph/IMPLEMENTATION_PLAN.md
2. Implement it (search first - don't assume not implemented)
3. Run tests to validate
4. Update @ralph/IMPLEMENTATION_PLAN.md (mark complete, update timestamp)
5. `git add -A && git commit && git push`
6. **EXIT** - the loop restarts you fresh

## Progress Reporting

```
[RALPH] BRANCH: <current branch>
[RALPH] === START: <task> ===
[RALPH] FILE: <file>
```

```
[RALPH] === DONE: <task> ===
[RALPH] RESULT: <summary>
```

## Issue Handling

1. Document issues in @ralph/IMPLEMENTATION_PLAN.md under "## Discovered Issues"
2. DO NOT work around problems - fix them or document them
3. If stuck >5 min, document and EXIT

## Rules

- ONE task, then EXIT
- Complete implementations only, no stubs
- No comments in code unless asked
EOF

  # Create empty implementation plan with branch info
  local current_branch=$(git branch --show-current)
  cat > "$IMPL_PLAN" << EOF
# Implementation Plan

**Branch:** \`$current_branch\`
**Last updated:** $(date '+%Y-%m-%d %H:%M')

Run \`ralph plan\` to generate this from specs.

## Pending Tasks

- [ ] (Add tasks here or run \`ralph plan\`)

## Completed

- (Tasks move here when done)

## Discovered Issues

- (Document issues found during implementation)
EOF

  # Create example spec
  cat > "$SPECS_DIR/example.md" << 'EOF'
# Example Specification

Delete this file and create your own specs.

## Overview

Describe what you want to build.

## Requirements

- Requirement 1
- Requirement 2

## Acceptance Criteria

- [ ] Criterion 1
- [ ] Criterion 2
EOF

  # Add logs to gitignore if not already there
  local gitignore="$REPO_ROOT/.gitignore"
  if [[ -f "$gitignore" ]]; then
    if ! grep -q "build/ralph-logs" "$gitignore"; then
      echo -e "\n# Ralph logs\nbuild/ralph-logs/" >> "$gitignore"
    fi
  fi

  echo -e "${GREEN}Ralph initialized!${NC}"
  echo ""
  echo "Next steps:"
  echo "  1. Write specs in ralph/specs/"
  echo "  2. Run 'ralph plan' to generate implementation plan"
  echo "  3. Run 'ralph' to start building"
  echo ""
  echo "Files created:"
  echo "  $RALPH_DIR/"
  echo "  ├── PROMPT_plan.md    (planning mode prompt)"
  echo "  ├── PROMPT_build.md   (build mode prompt)"
  echo "  ├── IMPLEMENTATION_PLAN.md"
  echo "  └── specs/"
  echo "      └── example.md    (delete and add your own)"
  echo ""
  echo "Claude commands (global): /ralph-init, /ralph-plan, /ralph-task, /ralph-status"
}

cmd_status() {
  if [[ ! -d "$RALPH_DIR" ]]; then
    echo -e "${YELLOW}Ralph not initialized. Run 'ralph init' first.${NC}"
    return 1
  fi

  echo -e "${BLUE}Ralph Status${NC}"
  echo "  Repo: $REPO_ROOT"
  echo "  Ralph dir: $RALPH_DIR"
  echo ""
  
  # Count specs
  local spec_count=$(find "$SPECS_DIR" -name "*.md" 2>/dev/null | wc -l)
  echo "  Specs: $spec_count files"
  
  # Count tasks
  if [[ -f "$IMPL_PLAN" ]]; then
    local pending=$(grep -c "^\- \[ \]" "$IMPL_PLAN" 2>/dev/null || echo 0)
    local done=$(grep -c "^\- \[x\]" "$IMPL_PLAN" 2>/dev/null || echo 0)
    echo "  Tasks: $pending pending, $done completed"
  else
    echo "  Tasks: No implementation plan yet"
  fi
  
  # Check for running ralph in THIS repo (look for opencode process with cwd in repo)
  local running_count=0
  while IFS= read -r pid; do
    if [[ -n "$pid" ]] && [[ -d "/proc/$pid" ]]; then
      local cwd=$(readlink -f "/proc/$pid/cwd" 2>/dev/null)
      if [[ "$cwd" == "$REPO_ROOT"* ]]; then
        running_count=$((running_count + 1))
      fi
    fi
  done < <(pgrep -x "opencode" 2>/dev/null)
  
  if [[ $running_count -gt 0 ]]; then
    echo -e "  Status: ${GREEN}Running${NC} ($running_count process(es))"
  else
    echo -e "  Status: ${YELLOW}Stopped${NC}"
  fi
  
  # Latest log
  local latest_log=$(ls -t "$LOG_DIR"/ralph-*.log 2>/dev/null | head -1)
  if [[ -n "$latest_log" ]]; then
    echo "  Latest log: $latest_log"
  fi
}

cmd_log() {
  local latest_log=$(ls -t "$LOG_DIR"/ralph-*.log 2>/dev/null | head -1)
  if [[ -z "$latest_log" ]]; then
    echo -e "${YELLOW}No logs found${NC}"
    return 1
  fi
  echo -e "${BLUE}Tailing: $latest_log${NC}"
  tail -f "$latest_log"
}

cmd_watch() {
  echo -e "${BLUE}Watching ralph progress... (Ctrl+C to stop)${NC}"
  echo ""
  
  while true; do
    clear
    echo -e "${BLUE}══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}  RALPH WATCH - $(date '+%H:%M:%S')${NC}"
    echo -e "${BLUE}══════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Branch
    echo -e "${GREEN}Branch:${NC} $(git branch --show-current)"
    echo ""
    
    # Process status - check for opencode running in THIS repo
    local running_count=0
    while IFS= read -r pid; do
      if [[ -n "$pid" ]] && [[ -d "/proc/$pid" ]]; then
        local cwd=$(readlink -f "/proc/$pid/cwd" 2>/dev/null)
        if [[ "$cwd" == "$REPO_ROOT"* ]]; then
          running_count=$((running_count + 1))
        fi
      fi
    done < <(pgrep -x "opencode" 2>/dev/null)
    
    if [[ $running_count -gt 0 ]]; then
      echo -e "${GREEN}Status:${NC} Running ($running_count)"
    else
      echo -e "${YELLOW}Status:${NC} Stopped"
    fi
    echo ""
    
    # Recent commits (last 5 min)
    echo -e "${GREEN}Recent Commits:${NC}"
    git log --oneline --since="5 minutes ago" 2>/dev/null | head -5 || echo "  (none in last 5 min)"
    echo ""
    
    # Current task
    echo -e "${GREEN}Next Task:${NC}"
    grep -m1 "^- \[ \]" "$IMPL_PLAN" 2>/dev/null | sed 's/^- \[ \] /  /' || echo "  (no pending tasks)"
    echo ""
    
    # Plan summary
    if [[ -f "$IMPL_PLAN" ]]; then
      local pending=$(grep -c "^- \[ \]" "$IMPL_PLAN" 2>/dev/null || echo 0)
      local done=$(grep -c "^- \[x\]" "$IMPL_PLAN" 2>/dev/null || echo 0)
      echo -e "${GREEN}Progress:${NC} $done done, $pending pending"
    fi
    echo ""
    
    # Discovered Issues
    if [[ -f "$IMPL_PLAN" ]]; then
      local issues=$(sed -n '/^## Discovered Issues/,/^## /{ /^## /d; /^$/d; p; }' "$IMPL_PLAN" 2>/dev/null | grep -c "^- " || echo 0)
      if [[ $issues -gt 0 ]]; then
        echo -e "${YELLOW}Discovered Issues:${NC} ($issues)"
        sed -n '/^## Discovered Issues/,/^## /{ /^## /d; /^$/d; p; }' "$IMPL_PLAN" 2>/dev/null | head -5 | sed 's/^/  /'
        if [[ $issues -gt 5 ]]; then
          echo -e "  ${YELLOW}... and $((issues - 5)) more${NC}"
        fi
        echo ""
      fi
    fi
    
    # Latest log lines
    echo -e "${GREEN}Latest Output:${NC}"
    local latest_log=$(ls -t "$LOG_DIR"/ralph-*.log 2>/dev/null | head -1)
    if [[ -n "$latest_log" && -s "$latest_log" ]]; then
      tail -8 "$latest_log" | sed 's/^/  /'
    else
      echo "  (no output yet)"
    fi
    echo ""
    echo -e "${BLUE}──────────────────────────────────────────────────────────────${NC}"
    echo "Refreshing every 5s..."
    
    sleep 5
  done
}

cmd_run() {
  local mode="$1"
  local max_iterations="${2:-0}"
  
  if [[ ! -d "$RALPH_DIR" ]]; then
    echo -e "${RED}Ralph not initialized. Run 'ralph init' first.${NC}"
    return 1
  fi

  local prompt_file
  if [[ "$mode" == "plan" ]]; then
    prompt_file="$PROMPT_PLAN"
  else
    prompt_file="$PROMPT_BUILD"
  fi

  if [[ ! -f "$prompt_file" ]]; then
    echo -e "${RED}Prompt file not found: $prompt_file${NC}"
    return 1
  fi

  local iteration=0
  local current_branch=$(git branch --show-current)
  local log_file="$LOG_DIR/ralph-$(date +%Y%m%d-%H%M%S).log"

  echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo -e "Mode:   ${GREEN}$mode${NC}"
  echo -e "Branch: $current_branch"
  echo -e "Log:    $log_file"
  [[ $max_iterations -gt 0 ]] && echo -e "Max:    $max_iterations iterations"
  echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

  while true; do
    if [[ $max_iterations -gt 0 ]] && [[ $iteration -ge $max_iterations ]]; then
      echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
      echo -e "Reached max iterations: $max_iterations"
      echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
      break
    fi

    iteration=$((iteration + 1))
    local start_time=$(date +%s)
    
    echo ""
    echo -e "${GREEN}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${GREEN}║  ITERATION $iteration - $(date '+%Y-%m-%d %H:%M:%S')                              ║${NC}"
    echo -e "${GREEN}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""

    # Run opencode with streaming output
    local script_dir
    script_dir="$(dirname "$(realpath "$0")")"
    local prompt_content
    prompt_content="$(cat "$prompt_file")"
    
    if [[ -x "$script_dir/ralph-stream" ]]; then
      # Stream JSON and filter for human-readable output
      opencode run --model anthropic/claude-opus-4-5 --format json "$prompt_content" 2>&1 | \
        tee -a "$log_file.json" | \
        "$script_dir/ralph-stream" | \
        tee -a "$log_file"
    else
      # Fallback: no streaming filter
      opencode run --model anthropic/claude-opus-4-5 "$prompt_content" 2>&1 | tee -a "$log_file"
    fi
    
    local exit_code=${PIPESTATUS[0]}
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    echo ""
    echo -e "${BLUE}┌───────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${BLUE}│  Iteration $iteration done in ${duration}s (exit: $exit_code)                     │${NC}"
    echo -e "${BLUE}└───────────────────────────────────────────────────────────────┘${NC}"

    # Push changes
    git push origin "$current_branch" 2>/dev/null || git push -u origin "$current_branch" 2>/dev/null || true

    # Show recent commits
    echo ""
    echo "Recent commits:"
    git log --oneline -3
    echo ""
  done
}

# ============================================================================
# Main
# ============================================================================

case "${1:-}" in
  init)
    cmd_init
    ;;
  status)
    cmd_status
    ;;
  log)
    cmd_log
    ;;
  watch)
    cmd_watch
    ;;
  plan)
    cmd_run "plan" "1"
    ;;
  ""|build)
    # Default to build mode
    if [[ "${1:-}" =~ ^[0-9]+$ ]]; then
      # ralph 10 -> build mode with 10 iterations
      cmd_run "build" "$1"
    else
      # ralph or ralph build
      cmd_run "build" "${2:-0}"
    fi
    ;;
  [0-9]*)
    # ralph 10 -> build mode with 10 iterations
    cmd_run "build" "$1"
    ;;
  help|--help|-h)
    echo "Ralph Wiggum - Autonomous AI Development Loop"
    echo ""
    echo "Usage: ralph [command] [iterations]"
    echo ""
    echo "Commands:"
    echo "  init          Initialize ralph in current repo"
    echo "  plan          Generate implementation plan from specs (runs once)"
    echo "  build [N]     Run build mode (implement from plan)"
    echo "  [N]           Shorthand for 'build N'"
    echo "  status        Show current status"
    echo "  watch         Live dashboard (run in separate terminal)"
    echo "  log           Tail the current log"
    echo "  help          Show this help"
    echo ""
    echo "Examples:"
    echo "  ralph init    # Initialize in current repo"
    echo "  ralph plan    # Generate implementation plan from specs"
    echo "  ralph         # Build mode, unlimited (Ctrl+C to stop)"
    echo "  ralph 10      # Build mode, max 10 iterations"
    echo "  ralph watch   # Live progress dashboard"
    ;;
  *)
    echo -e "${RED}Unknown command: $1${NC}"
    echo "Run 'ralph help' for usage"
    exit 1
    ;;
esac
