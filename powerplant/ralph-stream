#!/usr/bin/env python3
"""Filter opencode stream-json output to show human-readable progress."""

import json
import sys

for line in sys.stdin:
    line = line.strip()
    if not line:
        continue
    
    try:
        event = json.loads(line)
    except json.JSONDecodeError:
        continue
    
    event_type = event.get("type", "")
    part = event.get("part", {})
    
    # OpenCode format
    if event_type == "text":
        text = part.get("text", "")
        if text:
            print(f"\n{text}")
            sys.stdout.flush()
    
    elif event_type == "tool_call":
        tool = part.get("tool", "?")
        args = part.get("args", {})
        if tool == "bash":
            cmd = args.get("command", "")[:80]
            desc = args.get("description", "")
            print(f"\n[TOOL] Bash: {desc or cmd}")
        elif tool == "read":
            path = args.get("filePath", "")
            print(f"\n[TOOL] Read: {path}")
        elif tool == "edit":
            path = args.get("filePath", "")
            print(f"\n[TOOL] Edit: {path}")
        elif tool == "write":
            path = args.get("filePath", "")
            print(f"\n[TOOL] Write: {path}")
        elif tool == "grep":
            pattern = args.get("pattern", "")
            print(f"\n[TOOL] Grep: {pattern}")
        elif tool == "glob":
            pattern = args.get("pattern", "")
            print(f"\n[TOOL] Glob: {pattern}")
        else:
            print(f"\n[TOOL] {tool}")
        sys.stdout.flush()
    
    elif event_type == "tool_result":
        result = part.get("result", "")
        if result:
            lines = str(result).strip().split('\n')
            if len(lines) <= 3:
                for l in lines:
                    print(f"  {l[:100]}")
            else:
                print(f"  ({len(lines)} lines)")
            sys.stdout.flush()
    
    elif event_type == "step_finish":
        cost = part.get("cost", 0)
        tokens = part.get("tokens", {})
        input_tokens = tokens.get("input", 0)
        output_tokens = tokens.get("output", 0)
        cache_read = tokens.get("cache", {}).get("read", 0)
        print(f"\n{'='*60}")
        print(f"Cost: ${cost:.4f} | Tokens: {input_tokens}in/{output_tokens}out (cache: {cache_read})")
        print(f"{'='*60}")
        sys.stdout.flush()
