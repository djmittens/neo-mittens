"""BUILD stage for implementing tasks."""

from pathlib import Path
from typing import Optional

from ralph.config import GlobalConfig
from ralph.models import Task, RalphPlanConfig
from ralph.opencode import spawn_opencode, parse_json_stream, extract_metrics
from ralph.prompts import load_prompt
from ralph.stages.base import Stage, StageOutcome, StageResult
from ralph.state import RalphState
from ralph.utils import gen_id


def run(state: RalphState, config: GlobalConfig) -> StageResult:
    """Run the BUILD stage for the current task.

    Spawns an opencode process to implement the current task based on the BUILD stage prompt.

    Args:
        state: Current RalphState with tasks and context
        config: GlobalConfig with environment settings

    Returns:
        A StageResult indicating the outcome of the build stage
    """
    # Determine current task using state's current_task_id
    if not state.current_task_id:
        return StageResult(
            stage=Stage.BUILD,
            outcome=StageOutcome.SKIP,
            task_id=None,
            error="No current task to build",
        )

    # Find the current task from tasks
    current_task = next(
        (task for task in state.tasks if task.id == state.current_task_id), None
    )
    if not current_task:
        return StageResult(
            stage=Stage.BUILD,
            outcome=StageOutcome.FAILURE,
            task_id=state.current_task_id,
            error="Current task not found in task list",
        )

    # Load the build stage prompt
    try:
        prompt = load_prompt("build")
        # Include context about the task in the prompt
        prompt_context = f"""
TASK DETAILS:
- Name: {current_task.name}
- Notes: {current_task.notes}
- Acceptance Criteria: {current_task.accept or "No specific criteria provided"}
"""
        full_prompt = prompt_context + prompt
    except Exception as e:
        return StageResult(
            stage=Stage.BUILD,
            outcome=StageOutcome.FAILURE,
            task_id=current_task.id,
            error=f"Failed to load build prompt: {str(e)}",
        )

    # Spawn opencode process to implement the task
    try:
        process = spawn_opencode(full_prompt, cwd=Path.cwd(), timeout=config.timeout_ms)

        # Collect output
        output_str = process.stdout.read().decode("utf-8")
        output_list = list(parse_json_stream(output_str))

        # Extract metrics
        metrics = extract_metrics(output_str)
    except Exception as e:
        return StageResult(
            stage=Stage.BUILD,
            outcome=StageOutcome.FAILURE,
            task_id=current_task.id,
            error=f"OpenCode process failed: {str(e)}",
        )

    # Check if any output was generated
    if not output_list:
        return StageResult(
            stage=Stage.BUILD,
            outcome=StageOutcome.FAILURE,
            task_id=current_task.id,
            error="No output generated by OpenCode",
        )

    # Attempt to interpret the first output item (most likely to be the task)
    try:
        # Default to current task if no new task is generated
        new_tasks = []
        for output_item in output_list:
            if isinstance(output_item, dict) and output_item.get("name"):
                new_task = Task(
                    id=output_item.get("id", f"t-{gen_id()}"),
                    name=output_item["name"],
                    notes=output_item.get("notes", ""),
                    accept=output_item.get("accept", ""),
                    parent=current_task.id,
                    created_from=current_task.id,
                    priority=current_task.priority,
                )
                new_tasks.append(new_task)

        # Update state with new tasks
        if new_tasks:
            state.tasks.extend(new_tasks)
    except Exception as e:
        return StageResult(
            stage=Stage.BUILD,
            outcome=StageOutcome.FAILURE,
            task_id=current_task.id,
            error=f"Failed to process task outputs: {str(e)}",
        )

    # Return a successful result
    tokens_used = metrics.get("tokens_used", 0) if isinstance(metrics, dict) else 0
    cost = metrics.get("cost", 0.0) if isinstance(metrics, dict) else 0.0
    return StageResult(
        stage=Stage.BUILD,
        outcome=StageOutcome.SUCCESS,
        task_id=current_task.id,
        tokens_used=tokens_used,
        cost=cost,
    )

    # Find the current task from tasks
    current_task = next(
        (task for task in state.tasks if task.id == state.config.current_task), None
    )
    if not current_task:
        return StageResult(
            stage=Stage.BUILD,
            outcome=StageOutcome.FAILURE,
            message="Current task not found in task list",
        )

    # Load the build stage prompt
    try:
        prompt = load_prompt("build")
        # Include context about the task in the prompt
        prompt_context = f"""
TASK DETAILS:
- Name: {current_task.name}
- Notes: {current_task.notes}
- Acceptance Criteria: {current_task.accept or "No specific criteria provided"}
"""
        full_prompt = build_prompt_with_rules(prompt_context + prompt)
    except Exception as e:
        return StageResult(
            stage=Stage.BUILD,
            outcome=StageOutcome.FAILURE,
            message=f"Failed to load or build build prompt: {str(e)}",
        )

    # Spawn opencode process to implement the task
    try:
        process = spawn_opencode(
            full_prompt, cwd=Path.cwd(), timeout=config.timeout_ms or 600000
        )

        # Collect output
        output_list = list(parse_json_stream(process.stdout.read().decode("utf-8")))

        # Extract metrics
        metrics = extract_metrics(process.stdout.read().decode("utf-8"))
    except Exception as e:
        return StageResult(
            stage=Stage.BUILD,
            outcome=StageOutcome.FAILURE,
            message=f"OpenCode process failed: {str(e)}",
        )

    # Check if any output was generated
    if not output_list:
        return StageResult(
            stage=Stage.BUILD,
            outcome=StageOutcome.FAILURE,
            message="No output generated by OpenCode",
        )

    # Attempt to interpret the first output item (most likely to be the task)
    try:
        # Default to current task if no new task is generated
        new_tasks = []
        for output_item in output_list:
            if isinstance(output_item, dict) and output_item.get("name"):
                new_task = Task(
                    id=output_item.get("id", f"t-{gen_id()}"),
                    name=output_item["name"],
                    notes=output_item.get("notes", ""),
                    accept=output_item.get("accept", ""),
                    parent=current_task.id,
                    created_from=current_task.id,
                    priority=current_task.priority,
                )
                new_tasks.append(new_task)

        # Update state with new tasks or keep current task
        if new_tasks:
            state.tasks.extend(new_tasks)
    except Exception as e:
        return StageResult(
            stage=Stage.BUILD,
            outcome=StageOutcome.FAILURE,
            message=f"Failed to process task outputs: {str(e)}",
        )

    # Return a successful result
    return StageResult(
        stage=Stage.BUILD,
        outcome=StageOutcome.SUCCESS,
        message="Task build successful",
        metrics=metrics or Metrics(tokens_used=0, cost=0, iterations=1, duration=0),
    )
