.TH TQL 7 "February 2026" "tix" "Miscellaneous"
.SH NAME
tql \- Tix Query Language reference
.SH DESCRIPTION
TQL is a pipe\-based query language for the
.BR tix (1)
ticket system.
It provides a domain\-aware syntax that compiles to SQL, with automatic
enum translation, label table joins, and structured JSON output.
.PP
TQL is designed to be composable by agents and scripts without knowledge
of the underlying SQLite schema.
For queries that exceed TQL's expressiveness, use the raw SQL escape
hatch:
.BR "tix q sql" .
.SH SYNTAX
A TQL query is a pipeline of stages separated by
.B |
(pipe) characters:
.PP
.RS
.I source
.RI "| " filters " | " stage " | " stage " ..."
.RE
.PP
The first word must be a
.BR source .
Subsequent pipe segments contain filters or transformation stages.
Filters can also appear inline after the source keyword.
.SH SOURCES
The source determines which ticket types are included in the query.
.TP
.B tasks
Task tickets only (type=0).
.TP
.B issues
Issue tickets only (type=1).
.TP
.B notes
Note tickets only (type=2).
.TP
.B tickets
All ticket types (no type filter).
.SS The \fBall\fR modifier
By default, queries exclude resolved tickets (status >= 2: accepted,
rejected, deleted).
Only pending and done tickets are returned.
.PP
Append
.B all
after the source keyword to include resolved tickets:
.PP
.RS
.nf
tasks all
tasks all | status=accepted
issues all | sort resolved_at desc
.fi
.RE
.PP
The default exclusion is also suppressed when an explicit
.B status
filter is present:
.PP
.RS
.nf
tasks | status=accepted        \fR# no \fBall\fR needed\fP
tasks | status=deleted,rejected
.fi
.RE
.SH FILTERS
Filters restrict the result set.
Multiple filters within the same pipe segment combine with AND logic.
Each filter has the form
.IR field operator value .
.SS Operators
.TS
tab(|);
lb lb lb
l l l.
Operator|Syntax|SQL equivalent
equals|field=value|field = ?
not equals|field!=value|field != ?
greater than|field>value|field > ?
less than|field<value|field < ?
greater or equal|field>=value|field >= ?
less or equal|field<=value|field <= ?
pattern match|field~pattern|field LIKE ?
is empty|field=|field IS NULL OR field = ''
is not empty|field!=|field IS NOT NULL AND field != ''
in (OR logic)|field=a,b,c|field IN (?,?,?)
not in|field!=a,b,c|field NOT IN (?,?,?)
.TE
.SS Pattern matching
The
.B ~
operator uses glob\-style patterns converted to SQL LIKE:
.TP
.B *
matches any sequence (converted to
.BR % ).
.TP
.B ?
matches any single character (converted to
.BR _ ).
.PP
.B Example:
.B name~Build*
matches names starting with "Build".
.SS Enum sugar
Status, type, and priority fields accept human\-readable names that are
automatically translated to their integer values:
.PP
.TS
tab(|);
lb lb lb
l l l.
Field|Names|Values
status|pending, done, accepted, rejected, deleted|0, 1, 2, 3, 4
type|task, issue, note|0, 1, 2
priority|none, low, medium, high|0, 1, 2, 3
.TE
.PP
.B Example:
.B status=done
is equivalent to
.BR status=1 .
.SS Label filter
The pseudo\-field
.B label
triggers an automatic JOIN on the
.B ticket_labels
table:
.PP
.RS
.nf
tasks | label=blocked
tasks | label~module:*
.fi
.RE
.SS Negation prefix
Any filter can be negated by prefixing the field name with
.BR ! :
.PP
.RS
.nf
tasks | !status=done
tasks | !label=blocked
tasks | !name~Deploy*
.fi
.RE
.PP
For label filters,
.B !label=foo
uses a NOT EXISTS subquery to find tickets that do
.I not
have the specified label.
For comparison operators, negation flips the operator
(= becomes !=, > becomes <=, etc.).
.SS OR logic (comma values)
Multiple values can be specified with commas for OR logic:
.PP
.RS
.nf
tasks | status=pending,done
tasks | author=alice,bob,charlie
tasks | priority!=none,low
.fi
.RE
.PP
Comma\-separated values on
.B =
compile to SQL IN (...), and on
.B !=
compile to NOT IN (...).
Enum sugar applies to each value individually.
.SS Empty value (IS NULL / IS NOT NULL)
An empty value after the operator checks whether a field is set:
.PP
.RS
.nf
tasks | spec=              \fR# tasks with no spec\fP
tasks | spec!=             \fR# tasks that have a spec set\fP
tasks | branch!=           \fR# tasks with a branch set\fP
.fi
.RE
.PP
For string fields, this checks both NULL and empty string.
For numeric fields, this checks both NULL and zero.
.SS Quoted values
Values containing spaces can be quoted with double quotes:
.PP
.RS
.B name="Build the parser"
.RE
.SH STAGES
Stages transform the result set.
Each stage occupies its own pipe segment.
.SS distinct
Add DISTINCT to the SELECT clause, eliminating duplicate rows.
Typically combined with
.BR select :
.PP
.RS
.nf
tasks | distinct | select author
.fi
.RE
.SS select \fIf1,f2,...\fR
Choose specific columns instead of all columns.
Column names are comma\-separated with no spaces.
.PP
.RS
.nf
tasks | select id,name,author,branch
.fi
.RE
.SS group \fIfield\fR
Group results by a field.
Must be combined with at least one aggregate.
.PP
.RS
.nf
tasks | group author | count
tasks | group label | count
.fi
.RE
.PP
The special field
.B label
groups by the
.B ticket_labels
table (triggers a JOIN).
.SS count
Count rows (or rows per group if
.B group
is active).
Produces a
.B count
column in the output.
.SS sum \fIfield\fR
Sum a numeric field.
Produces a column named
.BI sum_ field
(e.g.,
.BR sum_cost ).
.SS avg \fIfield\fR
Average a numeric field.
Produces
.BI avg_ field .
.SS min \fIfield\fR
Minimum of a field.
Produces
.BI min_ field .
.SS max \fIfield\fR
Maximum of a field.
Produces
.BI max_ field .
.SS count_distinct \fIfield\fR
Count distinct values of a field.
Produces a column named
.BI count_distinct_ field .
.PP
.RS
.nf
tasks | group spec | count_distinct author
.fi
.RE
.SS having \fIcolumn\fR\fIop\fR\fIvalue\fR [\fIcolumn\fR\fIop\fR\fIvalue\fR ...]
Filter aggregate results.
The column name must match an aggregate alias
.RB ( count ", " sum_priority ", " avg_priority ", "
.BR count_distinct_author ", etc.)."
Multiple having filters can be space\-separated within the same segment.
.PP
.RS
.nf
tasks | group author | count | having count>=2
tasks | group author | count | having count>1
.fi
.RE
.SS sort \fIfield\fR [\fIasc\fR|\fIdesc\fR]
Order results by a field.
Default direction is
.BR asc .
Multiple sort fields can be specified, separated by commas or spaces.
.PP
When sorting aggregate results, use the aggregate column name:
.PP
.RS
.nf
tasks | group author | count | sort count desc
.fi
.RE
.PP
If no explicit sort is specified and the query is not an aggregate,
results are ordered by
.B priority DESC, created_at ASC
by default.
.SS limit \fIN\fR
Limit the number of returned rows.
.I N
must be a positive integer.
.SS offset \fIN\fR
Skip the first
.I N
rows (for pagination).
Can be used with or without
.BR limit .
If used without limit, an implicit unlimited limit is added
(required by SQLite).
.PP
.RS
.nf
tasks | sort created_at asc | limit 10 | offset 20
.fi
.RE
.SH AVAILABLE FIELDS
.TS
tab(|);
lb lb
l l.
Field|Description
id|ticket ID (e.g., T\-a1b2c3d4)
type|ticket type (0=task, 1=issue, 2=note)
status|status (0=pending, 1=done, 2=accepted, 3=rejected, 4=deleted)
priority|priority (0=none, 1=low, 2=medium, 3=high)
name|ticket name / description
spec|spec file path
notes|free\-form notes
accept|acceptance criteria
done_at|git commit hash when done
branch|git branch
parent|parent ticket ID
created_from|source ticket ID
supersedes|superseded ticket ID
kill_reason|reason task was killed
author|who created the ticket
assigned|who the ticket is assigned to
completed_at|ISO 8601 completion timestamp
created_at|creation unix epoch
updated_at|last update unix epoch
resolved_at|unix epoch when ticket reached terminal status
compacted_at|unix epoch when ticket was removed from plan.jsonl
label|pseudo\-field for ticket labels
meta.*|metadata pseudo\-field (see below)
.TE
.SS Metadata fields (meta.*)
The
.B meta.*
prefix accesses arbitrary key\-value metadata stored in the
.B ticket_meta
table.
Any key name is valid after the prefix (e.g.,
.BR meta.cost ", " meta.model ", " meta.tokens_in ).
.PP
For filters, numeric values compare against
.BR value_num ;
string values compare against
.BR value_text .
For aggregates (sum, avg, min, max),
.B value_num
is used.
For select and group\-by,
both columns are coalesced.
.PP
Each distinct meta key generates a LEFT JOIN, so tickets without
the requested metadata key are still returned (with NULL values).
A maximum of 4 distinct meta keys can be used in a single query.
.SH EXAMPLES
.PP
All pending tasks:
.RS
.B tix q "tasks"
.RE
.PP
High\-priority tasks by alice:
.RS
.B tix q "tasks | priority=high author=alice"
.RE
.PP
Task count per author, sorted:
.RS
.B tix q "tasks | group author | count | sort count desc"
.RE
.PP
Blocked issues in the parser module:
.RS
.B tix q "issues | label~module:parser*"
.RE
.PP
All tickets across types created after a timestamp:
.RS
.B tix q "tickets | created_at>1700000000 | select id,type,name"
.RE
.PP
Tasks with labels, grouped by label:
.RS
.B tix q "tasks | group label | count | sort count desc"
.RE
.PP
Pending or done tasks (OR logic):
.RS
.B tix q "tasks | status=pending,done"
.RE
.PP
Tasks NOT blocked:
.RS
.B tix q "tasks | !label=blocked"
.RE
.PP
Authors with 3+ tasks (HAVING):
.RS
.B tix q "tasks | group author | count | having count>=3"
.RE
.PP
Distinct authors who have tasks:
.RS
.B tix q "tasks | distinct | select author"
.RE
.PP
Unique contributors per spec:
.RS
.B tix q "tasks | group spec | count_distinct author"
.RE
.PP
Page 3 of results (10 per page):
.RS
.B tix q "tasks | sort created_at asc | limit 10 | offset 20"
.RE
.PP
Tasks with no spec assigned:
.RS
.B tix q "tasks | spec="
.RE
.PP
Tasks assigned to alice:
.RS
.B tix q "tasks | assigned=alice"
.RE
.PP
Unassigned tasks:
.RS
.B tix q "tasks | assigned="
.RE
.PP
Tasks NOT assigned to alice:
.RS
.B tix q "tasks | assigned!=alice"
.RE
.PP
All tasks including accepted and deleted:
.RS
.B tix q "tasks all"
.RE
.PP
Recently accepted tasks:
.RS
.B tix q "tasks | status=accepted | sort resolved_at desc | limit 10"
.RE
.PP
Deleted tasks with their resolution time:
.RS
.B tix q "tasks all | status=deleted | select id,name,resolved_at"
.RE
.PP
Tasks accepted or rejected:
.RS
.B tix q "tasks all | status=accepted,rejected"
.RE
.PP
Expensive tasks (cost > $1):
.RS
.B tix q "tasks | meta.cost>1.0 | select id,name,meta.cost"
.RE
.PP
Total cost by model:
.RS
.B tix q "tasks | group meta.model | sum meta.cost | sort sum_meta.cost desc"
.RE
.PP
Tasks with cost data:
.RS
.B tix q "tasks | meta.cost!="
.RE
.PP
Sort by cost descending:
.RS
.B tix q "tasks | sort meta.cost desc | limit 5"
.RE
.SH LIMITS
.TP
.B TQL_MAX_FILTERS
16 filters per query.
.TP
.B TQL_MAX_SELECT
16 selected fields.
.TP
.B TQL_MAX_SORTS
4 sort clauses.
.TP
.B TQL_MAX_AGGREGATES
8 aggregate functions per query.
.TP
.B TQL_MAX_HAVINGS
8 HAVING filters per query.
.TP
.B TQL_MAX_OR_VALUES
8 comma\-separated values per IN filter.
.TP
.B TQL_MAX_META_JOINS
4 distinct meta.* keys per query.
.TP
.B TQL_MAX_SQL_LEN
4096 bytes of generated SQL.
.TP
.B TQL_MAX_BINDS
48 bound parameters.
.SH SEE ALSO
.BR tix (1),
.BR tix\-query (1),
.BR tix\-plan (5)
